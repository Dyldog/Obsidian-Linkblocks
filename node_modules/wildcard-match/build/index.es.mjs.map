{"version":3,"file":"index.es.mjs","sources":["../src/transform.ts","../src/index.ts"],"sourcesContent":["/**\n * Escapes a character if it has a special meaning in regular expressions\n * and returns the character as is if it doesn't\n */\nfunction escapeRegExpChar(char: string) {\n  if (\n    char === '-' ||\n    char === '^' ||\n    char === '$' ||\n    char === '+' ||\n    char === '.' ||\n    char === '(' ||\n    char === ')' ||\n    char === '|' ||\n    char === '[' ||\n    char === ']' ||\n    char === '{' ||\n    char === '}' ||\n    char === '*' ||\n    char === '?' ||\n    char === '\\\\'\n  ) {\n    return `\\\\${char}`\n  } else {\n    return char\n  }\n}\n\n/**\n * Escapes all characters in a given string that have a special meaning in regular expressions\n */\nfunction escapeRegExpString(str: string) {\n  let result = ''\n  for (let i = 0; i < str.length; i++) {\n    result += escapeRegExpChar(str[i])\n  }\n  return result\n}\n\n/**\n * Transforms one or more glob patterns into a RegExp pattern\n */\nfunction transform(\n  pattern: string | string[],\n  separator: string | boolean = true\n): string {\n  if (Array.isArray(pattern)) {\n    let regExpPatterns = pattern.map((p) => `^${transform(p, separator)}$`)\n    return `(?:${regExpPatterns.join('|')})`\n  }\n\n  let separatorSplitter = ''\n  let separatorMatcher = ''\n  let wildcard = '.'\n\n  if (separator === true) {\n    // In this case forward slashes in patterns match both forward and backslashes in samples:\n    //\n    // `foo/bar` will match `foo/bar`\n    //           will match `foo\\bar`\n    //\n    separatorSplitter = '/'\n    separatorMatcher = '[/\\\\\\\\]'\n    wildcard = '[^/\\\\\\\\]'\n  } else if (separator) {\n    separatorSplitter = separator\n    separatorMatcher = escapeRegExpString(separatorSplitter)\n\n    if (separatorMatcher.length > 1) {\n      separatorMatcher = `(?:${separatorMatcher})`\n      wildcard = `((?!${separatorMatcher}).)`\n    } else {\n      wildcard = `[^${separatorMatcher}]`\n    }\n  }\n\n  // When a separator is explicitly specified in a pattern,\n  // it MUST match ONE OR MORE separators in a sample:\n  //\n  // `foo/bar/` will match  `foo//bar///`\n  //            won't match `foo/bar`\n  //\n  // When a pattern doesn't have a trailing separator,\n  // a sample can still optionally have them:\n  //\n  // `foo/bar` will match `foo/bar//`\n  //\n  // So we use different quantifiers depending on the index of a segment.\n  let requiredSeparator = separator ? `${separatorMatcher}+?` : ''\n  let optionalSeparator = separator ? `${separatorMatcher}*?` : ''\n\n  let segments = separator ? pattern.split(separatorSplitter) : [pattern]\n  let result = ''\n\n  for (let s = 0; s < segments.length; s++) {\n    let segment = segments[s]\n    let nextSegment = segments[s + 1]\n    let currentSeparator = ''\n\n    if (!segment && s > 0) {\n      continue\n    }\n\n    if (separator) {\n      if (s === segments.length - 1) {\n        currentSeparator = optionalSeparator\n      } else if (nextSegment !== '**') {\n        currentSeparator = requiredSeparator\n      } else {\n        currentSeparator = ''\n      }\n    }\n\n    if (separator && segment === '**') {\n      if (currentSeparator) {\n        result += s === 0 ? '' : currentSeparator\n        result += `(?:${wildcard}*?${currentSeparator})*?`\n      }\n      continue\n    }\n\n    for (let c = 0; c < segment.length; c++) {\n      let char = segment[c]\n\n      if (char === '\\\\') {\n        if (c < segment.length - 1) {\n          result += escapeRegExpChar(segment[c + 1])\n          c++\n        }\n      } else if (char === '?') {\n        result += wildcard\n      } else if (char === '*') {\n        result += `${wildcard}*?`\n      } else {\n        result += escapeRegExpChar(char)\n      }\n    }\n\n    result += currentSeparator\n  }\n\n  return result\n}\n\nexport default transform\n","import transform from './transform'\n\ninterface WildcardMatchOptions {\n  /** Separator to be used to split patterns and samples into segments */\n  separator?: string | boolean\n\n  /** Flags to pass to the RegExp */\n  flags?: string\n}\n\n// This overrides the function's signature because for the end user\n// the function is always bound to a RegExp\ninterface isMatch {\n  /**\n   * Tests if a sample string matches the pattern(s)\n   *\n   * ```js\n   * isMatch('foo') //=> true\n   * ```\n   */\n  (sample: string): boolean\n\n  /** Compiled regular expression */\n  regexp: RegExp\n\n  /** Original pattern or array of patterns that was used to compile the RegExp */\n  pattern: string | string[]\n\n  /** Options that were used to compile the RegExp */\n  options: WildcardMatchOptions\n}\n\nfunction isMatch(regexp: RegExp, sample: string) {\n  if (typeof sample !== 'string') {\n    throw new TypeError(`Sample must be a string, but ${typeof sample} given`)\n  }\n\n  return regexp.test(sample)\n}\n\n/**\n * Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n * The isMatch function takes a sample string as its only argument and returns `true`\n * if the string matches the pattern(s).\n *\n * ```js\n * wildcardMatch('src/*.js')('src/index.js') //=> true\n * ```\n *\n * ```js\n * const isMatch = wildcardMatch('*.example.com', '.')\n * isMatch('foo.example.com') //=> true\n * isMatch('foo.bar.com') //=> false\n * ```\n */\nfunction wildcardMatch(\n  pattern: string | string[],\n  options?: string | boolean | WildcardMatchOptions\n) {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError(\n      `The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`\n    )\n  }\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    options = { separator: options }\n  }\n\n  if (\n    arguments.length === 2 &&\n    !(\n      typeof options === 'undefined' ||\n      (typeof options === 'object' && options !== null && !Array.isArray(options))\n    )\n  ) {\n    throw new TypeError(\n      `The second argument must be an options object or a string/boolean separator, but ${typeof options} given`\n    )\n  }\n\n  options = options || {}\n\n  if (options.separator === '\\\\') {\n    throw new Error(\n      '\\\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead'\n    )\n  }\n\n  let regexpPattern = transform(pattern, options.separator)\n  let regexp = new RegExp(`^${regexpPattern}$`, options.flags)\n\n  let fn = isMatch.bind(null, regexp) as isMatch\n  fn.options = options\n  fn.pattern = pattern\n  fn.regexp = regexp\n  return fn\n}\n\nexport default wildcardMatch\n"],"names":[],"mappings":"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"}