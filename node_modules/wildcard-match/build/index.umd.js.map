{"version":3,"file":"index.umd.js","sources":["../src/transform.ts","../src/index.ts"],"sourcesContent":["/**\n * Escapes a character if it has a special meaning in regular expressions\n * and returns the character as is if it doesn't\n */\nfunction escapeRegExpChar(char: string) {\n  if (\n    char === '-' ||\n    char === '^' ||\n    char === '$' ||\n    char === '+' ||\n    char === '.' ||\n    char === '(' ||\n    char === ')' ||\n    char === '|' ||\n    char === '[' ||\n    char === ']' ||\n    char === '{' ||\n    char === '}' ||\n    char === '*' ||\n    char === '?' ||\n    char === '\\\\'\n  ) {\n    return `\\\\${char}`\n  } else {\n    return char\n  }\n}\n\n/**\n * Escapes all characters in a given string that have a special meaning in regular expressions\n */\nfunction escapeRegExpString(str: string) {\n  let result = ''\n  for (let i = 0; i < str.length; i++) {\n    result += escapeRegExpChar(str[i])\n  }\n  return result\n}\n\n/**\n * Transforms one or more glob patterns into a RegExp pattern\n */\nfunction transform(\n  pattern: string | string[],\n  separator: string | boolean = true\n): string {\n  if (Array.isArray(pattern)) {\n    let regExpPatterns = pattern.map((p) => `^${transform(p, separator)}$`)\n    return `(?:${regExpPatterns.join('|')})`\n  }\n\n  let separatorSplitter = ''\n  let separatorMatcher = ''\n  let wildcard = '.'\n\n  if (separator === true) {\n    // In this case forward slashes in patterns match both forward and backslashes in samples:\n    //\n    // `foo/bar` will match `foo/bar`\n    //           will match `foo\\bar`\n    //\n    separatorSplitter = '/'\n    separatorMatcher = '[/\\\\\\\\]'\n    wildcard = '[^/\\\\\\\\]'\n  } else if (separator) {\n    separatorSplitter = separator\n    separatorMatcher = escapeRegExpString(separatorSplitter)\n\n    if (separatorMatcher.length > 1) {\n      separatorMatcher = `(?:${separatorMatcher})`\n      wildcard = `((?!${separatorMatcher}).)`\n    } else {\n      wildcard = `[^${separatorMatcher}]`\n    }\n  }\n\n  // When a separator is explicitly specified in a pattern,\n  // it MUST match ONE OR MORE separators in a sample:\n  //\n  // `foo/bar/` will match  `foo//bar///`\n  //            won't match `foo/bar`\n  //\n  // When a pattern doesn't have a trailing separator,\n  // a sample can still optionally have them:\n  //\n  // `foo/bar` will match `foo/bar//`\n  //\n  // So we use different quantifiers depending on the index of a segment.\n  let requiredSeparator = separator ? `${separatorMatcher}+?` : ''\n  let optionalSeparator = separator ? `${separatorMatcher}*?` : ''\n\n  let segments = separator ? pattern.split(separatorSplitter) : [pattern]\n  let result = ''\n\n  for (let s = 0; s < segments.length; s++) {\n    let segment = segments[s]\n    let nextSegment = segments[s + 1]\n    let currentSeparator = ''\n\n    if (!segment && s > 0) {\n      continue\n    }\n\n    if (separator) {\n      if (s === segments.length - 1) {\n        currentSeparator = optionalSeparator\n      } else if (nextSegment !== '**') {\n        currentSeparator = requiredSeparator\n      } else {\n        currentSeparator = ''\n      }\n    }\n\n    if (separator && segment === '**') {\n      if (currentSeparator) {\n        result += s === 0 ? '' : currentSeparator\n        result += `(?:${wildcard}*?${currentSeparator})*?`\n      }\n      continue\n    }\n\n    for (let c = 0; c < segment.length; c++) {\n      let char = segment[c]\n\n      if (char === '\\\\') {\n        if (c < segment.length - 1) {\n          result += escapeRegExpChar(segment[c + 1])\n          c++\n        }\n      } else if (char === '?') {\n        result += wildcard\n      } else if (char === '*') {\n        result += `${wildcard}*?`\n      } else {\n        result += escapeRegExpChar(char)\n      }\n    }\n\n    result += currentSeparator\n  }\n\n  return result\n}\n\nexport default transform\n","import transform from './transform'\n\ninterface WildcardMatchOptions {\n  /** Separator to be used to split patterns and samples into segments */\n  separator?: string | boolean\n\n  /** Flags to pass to the RegExp */\n  flags?: string\n}\n\n// This overrides the function's signature because for the end user\n// the function is always bound to a RegExp\ninterface isMatch {\n  /**\n   * Tests if a sample string matches the pattern(s)\n   *\n   * ```js\n   * isMatch('foo') //=> true\n   * ```\n   */\n  (sample: string): boolean\n\n  /** Compiled regular expression */\n  regexp: RegExp\n\n  /** Original pattern or array of patterns that was used to compile the RegExp */\n  pattern: string | string[]\n\n  /** Options that were used to compile the RegExp */\n  options: WildcardMatchOptions\n}\n\nfunction isMatch(regexp: RegExp, sample: string) {\n  if (typeof sample !== 'string') {\n    throw new TypeError(`Sample must be a string, but ${typeof sample} given`)\n  }\n\n  return regexp.test(sample)\n}\n\n/**\n * Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n * The isMatch function takes a sample string as its only argument and returns `true`\n * if the string matches the pattern(s).\n *\n * ```js\n * wildcardMatch('src/*.js')('src/index.js') //=> true\n * ```\n *\n * ```js\n * const isMatch = wildcardMatch('*.example.com', '.')\n * isMatch('foo.example.com') //=> true\n * isMatch('foo.bar.com') //=> false\n * ```\n */\nfunction wildcardMatch(\n  pattern: string | string[],\n  options?: string | boolean | WildcardMatchOptions\n) {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError(\n      `The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`\n    )\n  }\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    options = { separator: options }\n  }\n\n  if (\n    arguments.length === 2 &&\n    !(\n      typeof options === 'undefined' ||\n      (typeof options === 'object' && options !== null && !Array.isArray(options))\n    )\n  ) {\n    throw new TypeError(\n      `The second argument must be an options object or a string/boolean separator, but ${typeof options} given`\n    )\n  }\n\n  options = options || {}\n\n  if (options.separator === '\\\\') {\n    throw new Error(\n      '\\\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead'\n    )\n  }\n\n  let regexpPattern = transform(pattern, options.separator)\n  let regexp = new RegExp(`^${regexpPattern}$`, options.flags)\n\n  let fn = isMatch.bind(null, regexp) as isMatch\n  fn.options = options\n  fn.pattern = pattern\n  fn.regexp = regexp\n  return fn\n}\n\nexport default wildcardMatch\n"],"names":["escapeRegExpChar","char","transform","pattern","separator","Array","isArray","map","p","join","separatorSplitter","separatorMatcher","wildcard","str","result","i","length","escapeRegExpString","requiredSeparator","optionalSeparator","segments","split","s","segment","nextSegment","currentSeparator","c","isMatch","regexp","sample","TypeError","test","options","arguments","Error","regexpPattern","RegExp","flags","fn","bind"],"mappings":"wOAIA,SAASA,EAAiBC,GACxB,MACW,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,OAATA,EAEO,KAAKA,EAELA,EAkBX,SAASC,EACPC,EACAC,GAEA,gBAFAA,MAEIC,MAAMC,QAAQH,GAEhB,MAAO,MADcA,EAAQI,KAAI,SAACC,GAAM,MAAA,IAAIN,EAAUM,EAAGJ,UAC7BK,KAAK,SAGnC,IAAIC,EAAoB,GACpBC,EAAmB,GACnBC,EAAW,KAEG,IAAdR,GAMFM,EAAoB,IACpBC,EAAmB,UACnBC,EAAW,YACFR,IAMPQ,GAJFD,EAnCJ,SAA4BE,GAE1B,IADA,IAAIC,EAAS,GACJC,EAAI,EAAGA,EAAIF,EAAIG,OAAQD,IAC9BD,GAAUd,EAAiBa,EAAIE,IAEjC,OAAOD,EA8BcG,CADnBP,EAAoBN,IAGCY,OAAS,EAEjB,QADXL,EAAmB,MAAMA,aAGd,KAAKA,OAsBpB,IANA,IAAIO,EAAoBd,EAAeO,OAAuB,GAC1DQ,EAAoBf,EAAeO,OAAuB,GAE1DS,EAAWhB,EAAYD,EAAQkB,MAAMX,GAAqB,CAACP,GAC3DW,EAAS,GAEJQ,EAAI,EAAGA,EAAIF,EAASJ,OAAQM,IAAK,CACxC,IAAIC,EAAUH,EAASE,GACnBE,EAAcJ,EAASE,EAAI,GAC3BG,EAAmB,GAEvB,GAAKF,KAAWD,EAAI,GAcpB,GAVIlB,IAEAqB,EADEH,IAAMF,EAASJ,OAAS,EACPG,EACM,OAAhBK,EACUN,EAEA,IAInBd,GAAyB,OAAZmB,EACXE,IACFX,GAAgB,IAANQ,EAAU,GAAKG,EACzBX,GAAU,MAAMF,OAAaa,aAHjC,CAQA,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAQP,OAAQU,IAAK,CACvC,IAAIzB,EAAOsB,EAAQG,GAEN,OAATzB,EACEyB,EAAIH,EAAQP,OAAS,IACvBF,GAAUd,EAAiBuB,EAAQG,EAAI,IACvCA,KAGFZ,GADkB,MAATb,EACCW,EACQ,MAATX,EACIW,OAEHZ,EAAiBC,GAI/Ba,GAAUW,GAGZ,OAAOX,EC7GT,SAASa,EAAQC,EAAgBC,GAC/B,GAAsB,iBAAXA,EACT,MAAM,IAAIC,UAAU,uCAAuCD,YAG7D,OAAOD,EAAOG,KAAKF,UAkBrB,SACE1B,EACA6B,GAEA,GAAuB,iBAAZ7B,IAAyBE,MAAMC,QAAQH,GAChD,MAAM,IAAI2B,UACR,0FAA0F3B,YAQ9F,GAJuB,iBAAZ6B,GAA2C,kBAAZA,IACxCA,EAAU,CAAE5B,UAAW4B,IAIF,IAArBC,UAAUjB,aAEW,IAAZgB,IACa,iBAAZA,GAAoC,OAAZA,GAAqB3B,MAAMC,QAAQ0B,IAGrE,MAAM,IAAIF,UACR,2FAA2FE,YAM/F,GAA0B,QAF1BA,EAAUA,GAAW,IAET5B,UACV,MAAM,IAAI8B,MACR,4GAIJ,IAAIC,EAAgBjC,EAAUC,EAAS6B,EAAQ5B,WAC3CwB,EAAS,IAAIQ,OAAO,IAAID,MAAkBH,EAAQK,OAElDC,EAAKX,EAAQY,KAAK,KAAMX,GAI5B,OAHAU,EAAGN,QAAUA,EACbM,EAAGnC,QAAUA,EACbmC,EAAGV,OAASA,EACLU"}